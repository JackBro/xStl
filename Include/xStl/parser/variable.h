/*
 * Copyright (c) 2008-2016, Integrity Project Ltd. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * Neither the name of the Integrity Project nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE
 */

#ifndef __TBA_XSTL_PARSER_VARIABLE_H
#define __TBA_XSTL_PARSER_VARIABLE_H

/*
 * variable.h
 *
 * Contains a code description of a variable.
 * A variable have a type and a content.
 *
 * Author: Elad Raz <e@eladraz.com>
 */
#include "xStl/types.h"
#include "xStl/data/string.h"
#include "xStl/parser/types.h"

/*
 * This class represnt a union of all known types.
 */
class BasicVariable
{
public:
    // Default constructor. Creates integer variable.
    BasicVariable();

    /*
     * Constructor. Builds a variable of solid type.
     *
     * type - The solid variable type
     */
    BasicVariable(Types::Type type);

    // Copy-constructor and operator = will be auto-generated by the compiler

    /*
     *    Return the type of the variable
     */
    Types::Type getType() const;

    /*
     * Return true if this variable type is a numeric one.
     */
    bool isInteger() const;

    /*
     * Return true if this variable type is string
     */
    bool isString() const;

    /*
     * Return true if this variable type is signed number
     */
    bool isSignedInteger() const;

    /*
     * Return true if this variable type is unsigned number
     */
    bool isUnsignedInteger() const;

    /*
     * Return the string content.
     * Throws exception for non-string types.
     */
    const cString& getString() const;

    /*
     * Change the string content to 'other'
     *
     * other - The string to be replace with
     *
     * Throws exception for non-string types.
     */
    void setString(const cString& other);

    /*
     * Return the integer content of this variable.
     * Throws exception for non-signed types.
     */
    int getSignedInteger() const;

    /*
     * Change the content of the signed variable.
     *
     * other - The integer to be replace
     *
     * Throws exception for non-signed types.
     * Throws exception incase of overflow
     */
    void setSignedInteger(int other);

    /*
     * Return the unsigned integer content of this variable.
     * Throws exception for non-unsigned types.
     */
    uint getUnsignedInteger() const;

    /*
     * Change the content of the unsigned variable.
     *
     * other - The integer to be replace
     *
     * Throws exception for non-unsigned types.
     * Throws exception incase of overflow
     */
    void setUnsignedInteger(uint other);

    /*
     * Translate the variable into a string value.
     */
    cString makeString() const;

private:
    // The debug magic eye-catcher
    static const uint32 EYE_CATCHER;

    // The type of the variable
    Types::Type m_type;

    // The content of the variable
    union {
        uint8   m_uint8;
        uint16  m_uint16;
        uint32  m_uint32;
        int8    m_int8;
        int16   m_int16;
        int32   m_int32;
    } m_data;

    // The string object needs a unique handling (Due to ctors etc..)
    // These avoid overflows.
    cString m_string;
};


/*
 * The variable with thier names.
 */
class VariableType
{
public:
    // Default ctor. Fills up the members.
    VariableType(const cString& name, const BasicVariable& data);
    // Copy constructor. operator = and defualt dtor will be generated by the compiler.

    /*
     * Return the name of the variable
     */
    const cString& getName() const;

    /*
     * Return the content of the variable for reading.
     */
    const BasicVariable& getData() const;

    /*
     * Return the content of the variable for reading/writing.
     */
    BasicVariable& getData();

private:
    // The name of variable
    cString m_name;
    // The content of the variable and it's name
    BasicVariable m_data;
};

#endif // __TBA_XSTL_PARSER_VARIABLE_H
