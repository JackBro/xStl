/*
 * Copyright (c) 2008-2016, Integrity Project Ltd. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * Neither the name of the Integrity Project nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE
 */

#ifndef __TBA_XSTL_REMOTEADDRESS_H
#define __TBA_XSTL_REMOTEADDRESS_H

/*
 * remoteAddress.h
 *
 * The remote-address is a variant number which can be encode and serialized in
 * several of encoding-types.
 *
 * Author: Elad Raz <e@eladraz.com>
 */
#include "xStl/types.h"
#include "xStl/operators.h"

#ifdef XSTL_16BIT
    // TODO! Fix 16 bit compilers. 64 bit integer are invalid for that compiler
    //       a class should be use instead
#else
    /*
     * The different ways for remote address stream encoding.
     * NOTE: This struct is not compiled for 16 bit applications since 16 bit
     *       compilers cannot work with 64 bit numbers and remoteAddressValues
     *
     * See basicInput::streamReadRemoteAddress
     * See basicInput::changeDecodedAddressType
     *
     * See basicOutput::streamWriteRemoteAddress
     * See basicOutput::changeEncodedAddressType
     */
    enum RemoteAddressEncodingTypes {
        // The remote address is encoded as 16 bit address
        REMOTE_ADDRESS_16BIT = 0,
        // The remote address is encoded as 32 bit address
        REMOTE_ADDRESS_32BIT = 1,
        // The remote address is encoded as 64 bit address
        REMOTE_ADDRESS_64BIT = 2,

        // The maximum address
        REMOTE_ADDRESS_MAX = REMOTE_ADDRESS_64BIT
    };

    //
    // The current machine address encoding
    // TODO! Change for 64bit machines
    //
    // NOTE: This value shouldn't be change by the user and must be set
    //       according to target compiler settings!
    #ifdef XSTL_64BIT
        #define DEFAULT_REMOTE_ADDRESS_ENCODING  REMOTE_ADDRESS_64BIT
    #else
        #define DEFAULT_REMOTE_ADDRESS_ENCODING  REMOTE_ADDRESS_32BIT
    #endif

    /*
     * The highest possible address encoding value for remote address as a
     * single uint64 bit number
     */
    typedef uint64 maxRemoteUint;

    /*
     * This struct encapsulate within it's member 4 different types of en
     */
    struct remoteAddressNumericValue {
        /*
         * Constructor. Translate
         */
        remoteAddressNumericValue();
        remoteAddressNumericValue(const maxRemoteUint& address,
                                  RemoteAddressEncodingTypes type =
                                    DEFAULT_REMOTE_ADDRESS_ENCODING);

        // Copy-constructor and operator = will auto generated by the compiler

        /*
         * Return the address cliped according to the bits settings of m_type
         */
        maxRemoteUint getClipedAddress() const;

        /*
         * Covert the remote address into the machine address number.
         *
         * Throw exception if the number of bits are bigger then the target
         * bits. (For example 32 bit machines trys to access 64 bit address)
         *
         * The number of bits in used is define for a machine by the
         * DEFAULT_REMOTE_ADDRESS_ENCODING preprocessor
         */
        addressNumericValue getAddressValue() const;

        /*
         * Check whether address is inside range
         *
         * start - The start address of the range
         * end   - The end address of the range
         *
         * Return true if this address is within [start..end], false otherwise.
         * Assert when (start > end) and return false in the release version.
         */
        bool isInsideRange(const remoteAddressNumericValue& start,
                           const remoteAddressNumericValue& end) const;

        /*
         * Operator ==. Compare two remote address.
         * NOTE: This function is better than NR_ADDRESS(a) == NR_ADDRESS(b)
         *       since it also clips the higher bits, depending on address-type
         */
        bool operator == (const remoteAddressNumericValue& other) const;

        // Operator <
        // See operator == for comments
        bool operator < (const remoteAddressNumericValue& other) const;

        // All other operators
        MAKE_SIMPLE_OPERATORS(remoteAddressNumericValue);


        // Public members

        // This struct doesn't have any method since it's as forward and simple
        // as possible.

        // All possible address encoding.
        // NOTE: Changing this struct must be done using NR_ADDRESS which change
        //       the 64 bit integer (=maxRemoteInt)
        union {
            uint64 m_64bitAddress;
            uint32 m_32bitAddress;
            uint16 m_16bitAddress;
        } m_union;

        // The type of the remote-address. Used for encoding and for
        // serialization
        RemoteAddressEncodingTypes m_type;
    };

    // The maximum value possible for remote-address
    #define MAX_REMOTE_ADDRESS ((maxRemoteUint)(-1))

    /*
     * Set of macros for helping using the remoteAddressNumericValue as a normal
     * integer type and commit all operation, such as =, +, - etc...
     *
     * Usage:
     *     remoteAddressNumericValue type;
     *     NR_ADDRESS(type) = 0;
     *     NR_ADDRESS(type)+= 500;
     */
    #define NR_ADDRESS(n) ((n).m_union.m_64bitAddress)
#endif

#endif // __TBA_XSTL_REMOTEADDRESS_H
